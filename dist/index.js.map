{"version":3,"sources":["../src/index.js"],"names":["genUID","rBytes","map","now","Date","getTime","nowS","toString","randA","c","push","Math","floor","random","length","join","PromisedEmitter","constructor","emitter","api","debug","context","uid","_emitter","_debug","_ctx","_uid","_unresolved","_events","_apiMethods","registerAPI","on","_listenerIsRegistered","event","i","_registerListener","res","filter","call","error","r","f","data","emit","Promise","handler","e","resolvePromisedResult","result","then","p","catch","err","found","forEach","method","obj","funcNames","Object","keys","name"],"mappings":"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","file":"index.js","sourcesContent":["// Generates a random unique identifier (12B hex by default)\nconst genUID = (rBytes = 8, map = [0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e']) => {\n  let now = new Date().getTime();\n  let nowS = ((now - (now % 1000)) / 1000).toString(16) // 4B timeStamp\n  let randA = [];\n  for (let c = 0; c < rBytes * 2; c++)\n    randA.push(map[Math.floor(Math.random() * map.length)])\n  return nowS + randA.join('');\n}\n\nclass PromisedEmitter {\n  constructor (emitter, api = {}, debug = false, context = null, uid = '__pEmitter') {\n    this._emitter = emitter;\n    this._debug = debug;\n    this._ctx = context;\n    this._uid = uid; // We will use this as a namespace for our \"\"\"\"protocol\"\"\"\" XD\n    this._unresolved = [];\n    this._events = [];\n    this._apiMethods = [];\n    // If provided register the API methods\n    if (api) this.registerAPI(api)\n    // Add a helper for the client to retrieve the\n    // available methods list\n    this.on('_getAPIMethods', () => {\n      return this._apiMethods;\n    });\n  }\n\n  // Check if a response listener is registered\n  _listenerIsRegistered (event) {\n    for (i in this._events) {\n      if (this._events[i] === event) return true;\n    }\n    return false;\n  }\n\n  // Registers an event to handle its responses\n  _registerListener (event) {\n    this._emitter.on(this._uid+'_R_'+event, (res) => {\n      this._unresolved = this._unresolved.filter((call) => {\n        if (call.uid === res.uid) {\n          if (res.error) {\n            call.r(res.error);\n          } else {\n            call.f(res.data);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n    });\n  }\n\n  // Emits an event and returns a promise to handle the response\n  emit (event, data) {\n    // If it's not already done, register a handler for the responses of the event\n    if (!this._listenerIsRegistered(event)) this._registerListener(event);\n    // Return a promise\n    return new Promise((f, r) => {\n      // Generate a unique ID for this call\n      let uid = genUID();\n      // Store the unresolved promise with its UID to keep track on it\n      this._unresolved.push({\n        uid: uid,\n        f: f,\n        r: r\n      });\n      // Emit the event with the same UID we stored for the promise\n      this._emitter.emit(this._uid+'_C_'+event, {\n        uid: uid,\n        data: data\n      });\n    });\n  }\n\n  // Registers an event listener\n  on (event, handler) {\n    // Register an event listener\n    this._emitter.on(this._uid+'_C_'+event, (e) => {\n      // Helper for resolving handlers that return a Promise\n      const resolvePromisedResult = (result) => {\n        if (result instanceof Promise ||Â (typeof result === 'object' && typeof result.then === 'function')) {\n          // Wait for the Promise to be fulfilled or rejected\n          let p = result.then((res) => {\n            resolvePromisedResult(res);\n          }).catch((err) => {\n            // If debugging is enabled send errors to the other end\n            if (this._debug) {\n              p.catch((err) => {\n                this._emitter.emit(this._uid+'_R_'+event, {\n                  uid: e.uid,\n                  error: err\n                });\n              });\n            } else {\n              throw err;\n            }\n          });\n        } else {\n          // Emit the response back\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            data: result\n          });\n        }\n      };\n      // If debugging is enabled send errors to the other end\n      if (this._debug) {\n        try {\n          // Call the handler and resolve the return if it's a Promise\n          resolvePromisedResult(handler(e.data, this._ctx));\n        } catch (err) {\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            error: err\n          })\n        }\n      } else {\n        // Call the handler and resolve the return if it's a Promise without handling any errors   \n        resolvePromisedResult(handler(e.data, this._ctx));\n      }\n    });\n    // Store the method name to this._apiMethods\n    let found = false;\n    this._apiMethods.forEach((method) => {\n      if (method === event)\n        found = true;\n    })\n    if (!found)\n      this._apiMethods.push(event);\n    // Let chain calls\n    return this;\n  }\n\n  // Registers a set of functions in batch\n  registerAPI (obj) {\n    let funcNames = Object.keys(obj);\n    funcNames.forEach((name) => {\n      if (typeof obj[name] === 'function') {\n        this.on(name, obj[name]);\n      }\n    });\n    return this;\n  }\n}\n\nexport default PromisedEmitter;\n"]}