{"version":3,"sources":["../src/index.js"],"names":["genUID","rBytes","map","now","Date","getTime","nowS","toString","randA","c","push","Math","floor","random","length","join","PromisedIO","emitter","api","debug","context","uid","_emitter","_debug","_ctx","_uid","_unresolved","_events","_apiMethods","registerAPI","on","event","i","res","filter","call","error","r","f","data","_listenerIsRegistered","_registerListener","Promise","emit","handler","e","resolvePromisedResult","result","then","p","catch","err","found","forEach","method","obj","funcNames","Object","keys","name"],"mappings":"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","file":"index.js","sourcesContent":["// Generates a random unique identifier (12B hex by default)\nconst genUID = (rBytes = 8, map = [0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e']) => {\n  let now = new Date().getTime();\n  let nowS = ((now - (now % 1000)) / 1000).toString(16) // 4B timeStamp\n  let randA = [];\n  for (let c = 0; c < rBytes * 2; c++)\n    randA.push(map[Math.floor(Math.random() * map.length)])\n  return nowS + randA.join('');\n}\n\nclass PromisedIO {\n  constructor (emitter, api = {}, debug = false, context = null, uid = '__pEmitter') {\n    this._emitter = emitter;\n    this._debug = debug;\n    this._ctx = context;\n    this._uid = uid; // We will use this as a namespace for our \"\"\"\"protocol\"\"\"\" XD\n    this._unresolved = [];\n    this._events = [];\n    this._apiMethods = [];\n    // If provided register the API methods\n    if (api) this.registerAPI(api)\n    // Add a helper for the client to retrieve the\n    // available methods list\n    this.on('_getAPIMethods', () => {\n      return this._apiMethods;\n    });\n  }\n\n  // Check if a response listener is registered\n  _listenerIsRegistered (event) {\n    for (i in this._events) {\n      if (this._events[i] === event) return true;\n    }\n    return false;\n  }\n\n  // Registers an event to handle its responses\n  _registerListener (event) {\n    this._emitter.on(this._uid+'_R_'+event, (res) => {\n      this._unresolved = this._unresolved.filter((call) => {\n        if (call.uid === res.uid) {\n          if (res.error) {\n            call.r(res.error);\n          } else {\n            call.f(res.data);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n    });\n  }\n\n  // Emits an event and returns a promise to handle the response\n  emit (event, data) {\n    // If it's not already done, register a handler for the responses of the event\n    if (!this._listenerIsRegistered(event)) this._registerListener(event);\n    // Return a promise\n    return new Promise((f, r) => {\n      // Generate a unique ID for this call\n      let uid = genUID();\n      // Store the unresolved promise with its UID to keep track on it\n      this._unresolved.push({\n        uid: uid,\n        f: f,\n        r: r\n      });\n      // Emit the event with the same UID we stored for the promise\n      this._emitter.emit(this._uid+'_C_'+event, {\n        uid: uid,\n        data: data\n      });\n    });\n  }\n\n  // Registers an event listener\n  on (event, handler) {\n    // Register an event listener\n    this._emitter.on(this._uid+'_C_'+event, (e) => {\n      // Helper for resolving handlers that return a Promise\n      const resolvePromisedResult = (result) => {\n        if (result instanceof Promise ||Â (typeof result === 'object' && typeof result.then === 'function')) {\n          // Wait for the Promise to be fulfilled or rejected\n          let p = result.then((res) => {\n            resolvePromisedResult(res);\n          }).catch((err) => {\n            // If debugging is enabled send errors to the other end\n            if (this._debug) {\n              p.catch((err) => {\n                this._emitter.emit(this._uid+'_R_'+event, {\n                  uid: e.uid,\n                  error: err\n                });\n              });\n            } else {\n              throw err;\n            }\n          });\n        } else {\n          // Emit the response back\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            data: result\n          });\n        }\n      };\n      // If debugging is enabled send errors to the other end\n      if (this._debug) {\n        try {\n          // Call the handler and resolve the return if it's a Promise\n          resolvePromisedResult(handler(e.data, this._ctx));\n        } catch (err) {\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            error: err\n          })\n        }\n      } else {\n        // Call the handler and resolve the return if it's a Promise without handling any errors   \n        resolvePromisedResult(handler(e.data, this._ctx));\n      }\n    });\n    // Store the method name to this._apiMethods\n    let found = false;\n    this._apiMethods.forEach((method) => {\n      if (method === event)\n        found = true;\n    })\n    if (!found)\n      this._apiMethods.push(event);\n    // Let chain calls\n    return this;\n  }\n\n  // Registers a set of functions in batch\n  registerAPI (obj) {\n    let funcNames = Object.keys(obj);\n    funcNames.forEach((name) => {\n      if (typeof obj[name] === 'function') {\n        this.on(name, obj[name]);\n      }\n    });\n    return this;\n  }\n}\n\nexport default PromisedIO;\n"]}