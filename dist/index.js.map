{"version":3,"sources":["../src/index.js"],"names":["genUID","rBytes","map","now","Date","getTime","nowS","toString","randA","c","push","Math","floor","random","length","join","PromisedEmitter","constructor","emitter","api","debug","uid","_emitter","_uid","_unresolved","_events","_apiMethods","registerAPI","on","_listenerIsRegistered","event","i","_registerListener","res","filter","call","error","r","f","data","emit","Promise","handler","e","resolvePromisedResult","result","then","p","catch","err","_debug","found","forEach","method","obj","funcNames","Object","keys","name"],"mappings":"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","file":"index.js","sourcesContent":["// Generates a random unique identifier (12B hex by default)\nconst genUID = (rBytes = 8, map = [0,1,2,3,4,5,6,7,8,9,'a','b','c','d','e']) => {\n  let now = new Date().getTime();\n  let nowS = ((now - (now % 1000)) / 1000).toString(16) // 4B timeStamp\n  let randA = [];\n  for (let c = 0; c < rBytes * 2; c++)\n    randA.push(map[Math.floor(Math.random() * map.length)])\n  return nowS + randA.join('');\n}\n\nclass PromisedEmitter {\n  constructor (emitter, api = {}, debug = false, uid = '__pEmitter') {\n    this._emitter = emitter;\n    this._uid = uid; // We will use this as a namespace for our \"\"\"\"protocol\"\"\"\" XD\n    this._unresolved = [];\n    this._events = [];\n    this._apiMethods = [];\n    // If provided register the API methods\n    if (api) this.registerAPI(api)\n    // Add a helper for the client to retrieve the\n    // available methods list\n    this.on('_getAPIMethods', () => {\n      return this._apiMethods;\n    });\n  }\n\n  // Check if a response listener is registered\n  _listenerIsRegistered (event) {\n    for (i in this._events) {\n      if (this._events[i] === event) return true;\n    }\n    return false;\n  }\n\n  // Registers an event to handle its responses\n  _registerListener (event) {\n    this._emitter.on(this._uid+'_R_'+event, (res) => {\n      this._unresolved = this._unresolved.filter((call) => {\n        if (call.uid === res.uid) {\n          if (res.error) {\n            call.r(res.error);\n          } else {\n            call.f(res.data);\n          }\n          return false;\n        } else {\n          return true;\n        }\n      });\n    });\n  }\n\n  // Emits an event and returns a promise to handle the response\n  emit (event, data) {\n    // If it's not already done, register a handler for the responses of the event\n    if (!this._listenerIsRegistered(event)) this._registerListener(event);\n    // Return a promise\n    return new Promise((f, r) => {\n      // Generate a unique ID for this call\n      let uid = genUID();\n      // Store the unresolved promise with its UID to keep track on it\n      this._unresolved.push({\n        uid: uid,\n        f: f,\n        r: r\n      });\n      // Emit the event with the same UID we stored for the promise\n      this._emitter.emit(this._uid+'_C_'+event, {\n        uid: uid,\n        data: data\n      });\n    });\n  }\n\n  // Registers an event listener\n  on (event, handler) {\n    // Register an event listener\n    this._emitter.on(this._uid+'_C_'+event, (e) => {\n      // Helper for resolving handlers that return a Promise\n      const resolvePromisedResult = (result) => {\n        if (result instanceof Promise ||Â (typeof result === 'object' && typeof result.then === 'function')) {\n          // Wait for the Promise to be fulfilled or rejected\n          let p = result.then((res) => {\n            resolvePromisedResult(res);\n          }).catch((err) => {\n            // If debugging is enabled send errors to the other end\n            if (this._debug) {\n              p.catch((err) => {\n                this._emitter.emit(this._uid+'_R_'+event, {\n                  uid: e.uid,\n                  error: err\n                });\n              });\n            } else {\n              throw err;\n            }\n          });\n        } else {\n          // Emit the response back\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            data: result\n          });\n        }\n      };\n      // If debugging is enabled send errors to the other end\n      if (this._debug) {\n        try {\n          // Call the handler and resolve the return if it's a Promise\n          resolvePromisedResult(handler(e.data));\n        } catch (err) {\n          this._emitter.emit(this._uid+'_R_'+event, {\n            uid: e.uid,\n            error: err\n          })\n        }\n      } else {\n        // Call the handler and resolve the return if it's a Promise without handling any errors   \n        resolvePromisedResult(handler(e.data));\n      }\n    });\n    // Store the method name to this._apiMethods\n    let found = false;\n    this._apiMethods.forEach((method) => {\n      if (method === event)\n        found = true;\n    })\n    if (!found)\n      this._apiMethods.push(event);\n    // Let chain calls\n    return this;\n  }\n\n  // Registers a set of functions in batch\n  registerAPI (obj) {\n    let funcNames = Object.keys(obj);\n    funcNames.forEach((name) => {\n      if (typeof obj[name] === 'function') {\n        this.on(name, obj[name]);\n      }\n    });\n    return this;\n  }\n}\n\nexport default PromisedEmitter;\n"]}